data = """
# paste your full input here, one "x,y" per line (no extra text)
97994,50070
97994,51278
97682,51278
97682,52505
97995,52505
97995,53745
98244,53745
98244,54964
98109,54964
98109,56103
97365,56103
97365,57313
97276,57313
97276,58596
97556,58596
97556,59830
97479,59830
97479,60989
97039,60989
97039,62039
96217,62039
96217,63145
95686,63145
95686,64448
95814,64448
95814,65748
95853,65748
95853,66647
94747,66647
94747,67740
94221,67740
94221,69177
94508,69177
94508,69966
93286,69966
93286,71118
92891,71118
92891,72251
92444,72251
92444,73132
91532,73132
91532,74291
91126,74291
91126,75674
91054,75674
91054,76263
89722,76263
89722,77520
89415,77520
89415,78190
88271,78190
88271,79203
87612,79203
87612,80165
86883,80165
86883,81041
86051,81041
86051,82014
85329,82014
85329,83391
85024,83391
85024,83904
83804,83904
83804,84522
82719,84522
82719,85478
81958,85478
81958,86562
81294,86562
81294,86931
80022,86931
80022,88355
79598,88355
79598,88998
78548,88998
78548,89076
77112,89076
77112,89777
76131,89777
76131,91003
75473,91003
75473,91653
74437,91653
74437,91715
73073,91715
73073,92720
72235,92720
72235,93032
71029,93032
71029,93510
69913,93510
69913,93849
68740,93849
68740,94361
67644,94361
67644,94984
66584,94984
66584,95653
65529,95653
65529,96098
64388,96098
64388,96560
63248,96560
63248,96428
61948,96428
61948,96495
60717,96495
60717,96844
59554,96844
59554,97070
58364,97070
58364,97854
57258,97854
57258,98024
56044,98024
56044,98135
54823,98135
54823,97727
53563,97727
53563,97475
52337,97475
52337,97900
51143,97900
51143,97724
49929,97724
49929,98019
48712,98019
48712,98154
47486,98154
47486,98236
46254,98236
46254,98092
45037,98092
45037,97874
43830,97874
43830,97381
42669,97381
42669,97498
41414,97498
41414,97371
40191,97371
40191,96505
39135,96505
39135,96596
37861,96596
37861,96307
36675,96307
36675,96011
35489,96011
35489,95113
34505,95113
34505,94957
33274,94957
33274,94735
32053,94735
32053,94046
31020,94046
31020,93731
29828,93731
29828,93348
28657,93348
28657,92289
27829,92289
27829,91861
26684,91861
26684,91469
25505,91469
25505,90441
24709,90441
24709,90456
23251,90456
23251,89722
22264,89722
22264,88735
21468,88735
21468,87709
20721,87709
20721,87366
19439,87366
19439,86196
18833,86196
18833,85478
17850,85478
17850,85024
16607,85024
16607,83796
16103,83796
16103,83109
15065,83109
15065,82305
14136,82305
14136,81022
13755,81022
13755,80387
12620,80387
12620,79261
12081,79261
12081,78324
11307,78324
11307,77449
10437,77449
10437,76125
10231,76125
10231,75270
9324,75270
9324,74200
8749,74200
8749,73000
8417,73000
8417,72212
7323,72212
7323,70999
7029,70999
7029,69923
6468,69923
6468,69035
5460,69035
5460,67816
5205,67816
5205,66499
5246,66499
5246,65319
4964,65319
4964,64209
4474,64209
4474,63212
3565,63212
3565,61927
3651,61927
3651,60738
3411,60738
3411,59645
2710,59645
2710,58413
2657,58413
2657,57226
2355,57226
2355,55990
2399,55990
2399,54814
1949,54814
1949,53595
1849,53595
1849,52341
2448,52341
2448,51146
1944,51146
1944,50065
94598,50065
94598,48717
2169,48717
2169,47489
1906,47489
1906,46273
1996,46273
1996,45076
2283,45076
2283,43838
2187,43838
2187,42737
3057,42737
3057,41440
2645,41440
2645,40280
3055,40280
3055,39120
3429,39120
3429,37828
3274,37828
3274,36754
3965,36754
3965,35579
4275,35579
4275,34377
4513,34377
4513,33327
5185,33327
5185,32309
5900,32309
5900,31151
6256,31151
6256,29783
6170,29783
6170,28753
6846,28753
6846,27522
7122,27522
7122,26666
8107,26666
8107,25368
8297,25368
8297,24548
9301,24548
9301,23431
9815,23431
9815,22558
10697,22558
10697,21334
11083,21334
11083,20740
12314,20740
12314,19686
12935,19686
12935,18704
13654,18704
13654,17977
14661,17977
14661,16842
15221,16842
15221,15856
15957,15856
15957,15485
17288,15485
17288,14164
17720,14164
17720,13794
19011,13794
19011,12618
19611,12618
19611,11630
20390,11630
20390,11270
21648,11270
21648,10386
22514,10386
22514,9894
23652,9894
23652,9053
24561,9053
24561,8745
25796,8745
25796,8325
26949,8325
26949,7285
27767,7285
27767,7219
29093,7219
29093,6721
30191,6721
30191,5999
31194,5999
31194,5092
32138,5092
32138,5165
33470,5165
33470,4821
34632,4821
34632,4323
35742,4323
35742,4226
36975,4226
36975,3808
38112,3808
38112,3519
39286,3519
39286,3211
40456,3211
40456,2462
41552,2462
41552,2979
42867,2979
42867,2613
44035,2613
44035,1875
45178,1875
45178,2010
46416,2010
46416,2152
47644,2152
47644,2087
48856,2087
48856,2499
50070,2499
50070,2291
51279,2291
51279,1773
52517,1773
52517,2521
53686,2521
53686,2466
54904,2466
54904,2421
56130,2421
56130,2980
57274,2980
57274,3195
58460,3195
58460,2978
59735,2978
59735,3035
60971,3035
60971,3947
61996,3947
61996,3800
63293,3800
63293,3990
64510,3990
64510,4924
65481,4924
65481,5179
66674,5179
66674,5726
67760,5726
67760,5941
68983,5941
68983,6523
70053,6523
70053,6737
71300,6737
71300,7305
72382,7305
72382,7710
73554,7710
73554,8877
74289,8877
74289,9362
75412,9362
75412,10309
76242,10309
76242,10551
77543,10551
77543,11204
78576,11204
78576,12164
79376,12164
79376,12717
80491,12717
80491,13412
81503,13412
81503,14593
82084,14593
82084,15145
83229,15145
83229,15950
84150,15950
84150,17034
84782,17034
84782,17694
85863,17694
85863,18932
86297,18932
86297,19445
87585,19445
87585,20914
87690,20914
87690,21842
88464,21842
88464,22561
89546,22561
89546,23717
90007,23717
90007,24543
90975,24543
90975,25513
91737,25513
91737,26805
91934,26805
91934,27736
92775,27736
92775,28815
93348,28815
93348,30007
93680,30007
93680,31263
93839,31263
93839,32086
95037,32086
95037,33557
94598,33557
94598,34686
95017,34686
95017,35644
95992,35644
95992,36904
96023,36904
96023,38064
96379,38064
96379,39183
96924,39183
96924,40440
96868,40440
96868,41593
97302,41593
97302,42850
97132,42850
97132,43965
97949,43965
97949,45203
97868,45203
97868,46434
97749,46434
97749,47650
97724,47650
97724,48856
97917,48856
97917,50070

"""

from bisect import bisect_right
from collections import defaultdict

def parse_input(text):
    pts=[]
    for line in text.strip().splitlines():
        line=line.strip()
        if not line or line.startswith('#'):
            continue
        x_str,y_str=line.split(',',1)
        pts.append((int(x_str.strip()),int(y_str.strip())))
    return pts

pts = parse_input(data)
n = len(pts)
if n == 0:
    print(0)
    raise SystemExit

# sets for red tiles and edge (line) tiles
red = set(pts)
edge = set()

# build vertical edges list for scanline intersections
vertical_edges = []  # tuples (x, ymin, ymax) with ymin < ymax

for i in range(n):
    x1,y1 = pts[i]
    x2,y2 = pts[(i+1) % n]
    if x1 == x2:
        ymin = min(y1,y2)
        ymax = max(y1,y2)
        vertical_edges.append((x1, ymin, ymax))
        # mark the vertical edge tiles (inclusive)
        for yy in range(ymin, ymax+1):
            edge.add((x1, yy))
    elif y1 == y2:
        xmin = min(x1,x2)
        xmax = max(x1,x2)
        # mark the horizontal edge tiles (inclusive)
        for xx in range(xmin, xmax+1):
            edge.add((xx, y1))
    else:
        # according to puzzle, adjacent points are always same row or column
        raise ValueError("Input adjacent points not axis-aligned")

min_y = min(y for _,y in pts)
max_y = max(y for _,y in pts)

# Precompute for each integer row y the interior x-intervals (inclusive)
# We consider horizontal scanline at y+0.5; a vertical edge (x,ymin..ymax) intersects that
# scanline iff ymin <= y < ymax. For intersections we collect the x's and pair them.
rows_intervals = {}  # y -> list of (x_start, x_end) inclusive, merged and sorted

for y in range(min_y, max_y):
    xs = []
    for x, ymin, ymax in vertical_edges:
        if ymin <= y < ymax:
            xs.append(x)
    if not xs:
        continue
    xs.sort()
    intervals = []
    # pair intersections; interior x tiles satisfy x_i <= x < x_{i+1} -> integer x in [x_i, x_{i+1}-1]
    for k in range(0, len(xs)-1, 2):
        a = xs[k]
        b = xs[k+1]
        if a <= b-1:
            intervals.append((a, b-1))
    if not intervals:
        continue
    # merge intervals (defensive)
    merged = []
    cur_s, cur_e = intervals[0]
    for s,e in intervals[1:]:
        if s <= cur_e+1:
            if e > cur_e:
                cur_e = e
        else:
            merged.append((cur_s, cur_e))
            cur_s, cur_e = s, e
    merged.append((cur_s, cur_e))
    rows_intervals[y] = merged

# Helper: check if for a given row y the entire x-range [xs, xe] is allowed (green or red)
def row_covers(y, xs, xe):
    # if row has precomputed interior intervals
    if y in rows_intervals:
        intervals = rows_intervals[y]
        # binary search for interval that might contain xs
        lo = 0
        hi = len(intervals)
        # find rightmost interval with start <= xs
        idx = bisect_right(intervals, (xs, 10**18)) - 1
        if idx >= 0:
            s,e = intervals[idx]
            if s <= xs and e >= xe:
                return True
        # maybe xs lies on an edge or red tiles cover continuous span (rare) -> fallback to checking each x
    # fallback: small-width direct check (cover by edge or red)
    # to avoid huge loops, if width is very large and we don't have interval data, return False
    width = xe - xs + 1
    if width > 5000:
        return False
    for xx in range(xs, xe+1):
        if (xx, y) in red or (xx, y) in edge:
            continue
        # also check interior intervals (if any) that might include this xx
        if y in rows_intervals:
            covered = False
            for s,e in rows_intervals[y]:
                if s <= xx <= e:
                    covered = True
                    break
            if covered:
                continue
        return False
    return True

# iterate over all unordered pairs of red tiles as opposite corners
reds = list(red)
m = len(reds)
max_area = 0

for i in range(m):
    x1,y1 = reds[i]
    for j in range(i+1, m):
        x2,y2 = reds[j]
        if x1 == x2 or y1 == y2:
            continue
        xs = min(x1,x2)
        xe = max(x1,x2)
        ys = min(y1,y2)
        ye = max(y1,y2)
        # quick area upper bound check
        area = (xe - xs + 1) * (ye - ys + 1)
        if area <= max_area:
            continue
        ok = True
        # check each scan row in rectangle (use rows_intervals which were computed for y in [min_y, max_y-1])
        for y in range(ys, ye+1):
            if not row_covers(y, xs, xe):
                ok = False
                break
        if ok and area > max_area:
            max_area = area

print(max_area)
